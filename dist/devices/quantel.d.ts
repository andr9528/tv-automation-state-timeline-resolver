import { DeviceWithState, DeviceStatus, IDevice } from './device';
import { DeviceType, QuantelOptions, QuantelControlMode, QuantelOutTransition, DeviceOptionsQuantel } from '../types/src';
import { TimelineState } from 'superfly-timeline';
export interface DeviceOptionsQuantelInternal extends DeviceOptionsQuantel {
    options: (DeviceOptionsQuantel['options'] & {
        commandReceiver?: CommandReceiver;
    });
}
export declare type CommandReceiver = (time: number, cmd: QuantelCommand, context: string, timelineObjId: string) => Promise<any>;
/**
 * This class is used to interface with a Quantel-gateway,
 * https://github.com/nrkno/tv-automation-quantel-gateway
 *
 * This device behaves a little bit different than the others, because a play-command is
 * a two-step rocket.
 * This is why the commands generated by the state-diff is not one-to-one related to the
 * actual commands sent to the Quantel-gateway.
 */
export declare class QuantelDevice extends DeviceWithState<QuantelState> implements IDevice {
    private _quantel;
    private _quantelManager;
    private _commandReceiver;
    private _doOnTime;
    private _doOnTimeBurst;
    private _initOptions?;
    constructor(deviceId: string, deviceOptions: DeviceOptionsQuantelInternal, options: any);
    init(initOptions: QuantelOptions): Promise<boolean>;
    /**
     * Terminates the device safely such that things can be garbage collected.
     */
    terminate(): Promise<boolean>;
    /** Called by the Conductor a bit before a .handleState is called */
    prepareForHandleState(newStateTime: number): void;
    /**
     * Generates an array of Quantel commands by comparing the newState against the oldState, or the current device state.
     */
    handleState(newState: TimelineState): void;
    /**
     * Attempts to restart the gateway
     */
    restartGateway(): Promise<any>;
    /**
     * Clear any scheduled commands after this time
     * @param clearAfterTime
     */
    clearFuture(clearAfterTime: number): void;
    get canConnect(): boolean;
    get connected(): boolean;
    get deviceType(): DeviceType;
    get deviceName(): string;
    get queue(): {
        id: string;
        queueId: string;
        time: number;
        args: any[];
    }[];
    private _getMappedPorts;
    /**
     * Takes a timeline state and returns a Quantel State that will work with the state lib.
     * @param timelineState The timeline state to generate from.
     */
    convertStateToQuantel(timelineState: TimelineState): QuantelState;
    /**
     * Prepares the physical device for playout.
     * @param okToDestroyStuff Whether it is OK to do things that affects playout visibly
     */
    makeReady(okToDestroyStuff?: boolean): Promise<void>;
    getStatus(): DeviceStatus;
    private _diffStates;
    private _doCommand;
    /**
     * Use either AMCP Command Scheduling or the doOnTime to execute commands at
     * {@code time}.
     * @param commandsToAchieveState Commands to be added to queue
     * @param time Point in time to send commands at
     */
    private _addToQueue;
    /**
     * Sends commands to the Quantel ISA server
     * @param time deprecated
     * @param cmd Command to execute
     */
    private _defaultCommandReceiver;
    private _connectionChanged;
}
interface QuantelState {
    time: number;
    port: {
        [portId: string]: QuantelStatePort;
    };
}
interface QuantelStatePort {
    timelineObjId: string;
    clip?: QuantelStatePortClip;
    mode: QuantelControlMode;
    lookahead: boolean;
    channels: number[];
    notOnAir?: boolean;
    outTransition?: QuantelOutTransition;
}
interface QuantelStatePortClip {
    title?: string;
    guid?: string;
    clipId?: number;
    playing: boolean;
    playTime: number | null;
    pauseTime?: number;
    inPoint?: number;
    length?: number;
}
interface QuantelCommandBase {
    time: number;
    type: QuantelCommandType;
    portId: string;
    timelineObjId: string;
    fromLookahead?: boolean;
}
export declare enum QuantelCommandType {
    SETUPPORT = "setupPort",
    LOADCLIPFRAGMENTS = "loadClipFragments",
    PLAYCLIP = "playClip",
    PAUSECLIP = "pauseClip",
    CLEARCLIP = "clearClip",
    RELEASEPORT = "releasePort"
}
interface QuantelCommandSetupPort extends QuantelCommandBase {
    type: QuantelCommandType.SETUPPORT;
    channel: number;
}
interface QuantelCommandLoadClipFragments extends QuantelCommandBase {
    type: QuantelCommandType.LOADCLIPFRAGMENTS;
    clip: QuantelStatePortClip;
    /** The time the clip is scheduled to play */
    timeOfPlay: number;
}
interface QuantelCommandClip extends QuantelCommandBase {
    clip: QuantelStatePortClip;
    mode: QuantelControlMode;
    transition?: QuantelOutTransition;
}
interface QuantelCommandPlayClip extends QuantelCommandClip {
    type: QuantelCommandType.PLAYCLIP;
}
interface QuantelCommandPauseClip extends QuantelCommandClip {
    type: QuantelCommandType.PAUSECLIP;
}
interface QuantelCommandClearClip extends QuantelCommandBase {
    type: QuantelCommandType.CLEARCLIP;
    transition?: QuantelOutTransition;
}
interface QuantelCommandReleasePort extends QuantelCommandBase {
    type: QuantelCommandType.RELEASEPORT;
}
declare type QuantelCommand = QuantelCommandSetupPort | QuantelCommandLoadClipFragments | QuantelCommandPlayClip | QuantelCommandPauseClip | QuantelCommandClearClip | QuantelCommandReleasePort;
export {};
